#!/bin/bash
make_pyfiles () {
cat > .gitignore << EOF
# Created by https://www.gitignore.io/v1/example,visualstudiocode,virtualenv
# Edit at https://www.gitignore.io/?templates=python,visualstudiocode,virtualenv

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# Mr Developer
.mr.developer.cfg
.project
.pydevproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

### VirtualEnv ###
# Virtualenv
# http://iamzed.com/2009/05/07/a-primer-on-virtualenv/
pyvenv.cfg
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
pip-selfcheck.json

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

### VisualStudioCode Patch ###
# Ignore all local history of files
.history

# End of https://www.gitignore.io/v1/example,visualstudiocode,virtualenv
#temporal archives
*~
#poetry
poetry.lock
#pyC
*.pyc
#coderuner
tempCodeRunnerFile.py
EOF

cat > server.py << EOF
from flask import Flask, jsonify
from config import DevelopmentConfig
from routes.example_routes import example
app = Flask(__name__)
app.config.from_object(DevelopmentConfig)


# * Error 404
@app.errorhandler(404)
def page_not_found(err):
    return jsonify({"Message": "This page could not be found"})


# * Error 405
@app.errorhandler(405)
def method_not_allowed(err):
    return jsonify({"Message": "The method is not allowed for the requested URL"})


# * Error 401
@app.errorhandler(401)
def method_not_allowed(err):
    return jsonify({'Authenticate': 'Could not verify'})


# * Routes
app.register_blueprint(example)
EOF

cat > run.py << EOF
from server import app
from models import ma
from models import db, create_database


if __name__ == "__main__":
    db.init_app(app)
    ma.init_app(app)
    with app.app_context():
        create_database()
        db.create_all()
    app.run()
EOF

cat > config/__init__.py << EOF
from os import environ
from models.table_example import TableExample


class Config:
    SECRET_KEY = "CRAG"


class DevelopmentConfig(Config):
    DEBUG = True
    EGINE_URI = 'mysql://root:' + environ['passmaria'] + '@localhost'
    # * EGINE_URI = 'mysql://root:@localhost'
    DB_NAME = 'example_db'
    SQLALCHEMY_DATABASE_URI = f'{EGINE_URI}/{DB_NAME}'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    TABLE_VALIDATE_TOKEN = TableExample
EOF

cat > models/__init__.py << EOF
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from sqlalchemy import exc
from flask import current_app as app
db = SQLAlchemy()
ma = Marshmallow()


class Standard:
    def save(self) -> bool:
        db.session.add(self)
        try:
            db.session.commit()
        except exc.SQLAlchemyError:
            db.session.rollback()
            return False
        return True

    def delete(self, *args) -> bool:
        db.session.delete(self)
        try:
            db.session.commit()
        except exc.SQLAlchemyError:
            db.session.rollback()
            return False
        return True


def create_database():
    engine = db.create_engine(app.config['EGINE_URI'], {})
    engine.execute(f"CREATE DATABASE IF NOT EXISTS {app.config['DB_NAME']}")


from .table_example import TableExample
EOF

cat > routes/__init__.py << EOF
from flask import Blueprint
example = Blueprint('example', __name__)
EOF

cat > routes/api_template.py << EOF
from flask import jsonify, request, abort
from flask.views import MethodView
import jwt
from flask import current_app as app
import datetime
from helpers.validations import token_required, validate_json
from models import ma
from models.Login import LoginSchema


class MethodsApi(MethodView):
    def __init__(self, table, table_schema, customize_login: dict = None):
        if customize_login is None:
            customize_login = {}
        self.customize_login = customize_login
        self.Table = table
        self.Result: ma.Schema = table_schema()
        self.Results: ma.Schema = table_schema(many=True)
        self.login = validate_json(customize_login.get("schema", LoginSchema)())(self.login)
        self.put = validate_json(self.Result)(self.put)
        self.add = validate_json(self.Result)(self.add)

    @token_required()
    def get(self, current_user, id=None):
        print(current_user)
        if id:
            one_registry = self.Table.query.get_or_404(id)
            return self.Result.jsonify(one_registry)

        if 'page' in request.args.keys():
            page = int(request.args.get('page'))
            per_page = int(request.args.get('size', 10))
            paginar = self.Table.query.paginate(page, per_page, False)
            if not paginar.items:
                abort(404)
            return jsonify(
                {"Result": self.Results.dump(paginar.items),
                 "total-pages": paginar.pages})

        all_registrys = self.Table.query.all()
        if not all_registrys:
            abort(404)
        return self.Results.jsonify(all_registrys)

    def post(self):
        rute = str(request.url_rule)
        if rute.find('login') != -1:
            return self.login()
        return self.add()

    def login(self):
        auth = request.json
        search = {
            self.customize_login.get('field_search', "email"): auth[
                self.customize_login.get('field_search', "email")
            ]}

        user = self.Table.query.filter_by(**search).first()

        if not user:
            abort(401)

        if user.compare_passwords(auth[self.customize_login.get('password_field_name', "password")]):
            token = jwt.encode({
                'id': user.id,
                'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30),
            }, self.customize_login.get('key_encrypt', app.config['SECRET_KEY']))
            action = self.customize_login.get('post_action', False)
            if action:
                exec(f'action[0]({action[1]})')
            return jsonify({'token': token.decode('UTF-8')})
        abort(401)

    @token_required()
    def add(self, current_user):
        new_registry = self.Table(request.json, current_user)
        insert_correct_data = new_registry.save()
        if not insert_correct_data:
            return self.databse_err()
        return self.Result.jsonify(new_registry), 201

    @token_required()
    def put(self, current_user, id):
        registry_update = self.Table.query.get_or_404(id)
        registry_update.changes(request.json, current_user)
        update_correct_data = registry_update.save()
        if not update_correct_data:
            return self.databse_err("update")
        return self.Result.jsonify(registry_update)

    @token_required()
    def delete(self, current_user, id):
        registry_delete = self.Table.query.get_or_404(id)
        deleted_data = registry_delete.delete(current_user)
        if not deleted_data:
            return self.databse_err("delete")
        return self.Result.jsonify(registry_delete)

    @staticmethod
    def databse_err(action: str = "insert") -> jsonify:
        return jsonify(
            {"Err": f"Error trying to {action} data"}), 409
EOF

cat > routes/create_routesStandars.py <<EOF
from routes.api_template import MethodsApi


def create_routes(**kwargs):
    view_func = MethodsApi.as_view(
        f"{kwargs.get('noun')}_api",
        kwargs.get('table'),
        kwargs.get('table_schema'),
        kwargs.get('customize_login')
    )

    endpoints = kwargs.get(
        'endpoints',
        get_endpoints(
            kwargs.get('noun'),
            kwargs.get('login_endpoint', False)))

    for i in endpoints:
        kwargs.get('blueprint').add_url_rule(
            i[0],
            methods=i[1],
            view_func=view_func)


def get_endpoints(noun: str, login: bool) -> list:
    endpoint_list = [
        [f'/api/{noun}/', ['POST', 'GET']],
        [f'/api/{noun}/<int:id>', ['GET', 'PUT', 'DELETE']]]
    if login:
        endpoint_list.insert(0, [f'/api/{noun}/login', ['POST']])
    return endpoint_list
EOF

cat > requirements.txt << EOF
flask
flask_sqlalchemy
flask_marshmallow
marshmallow-sqlalchemy
mysqlclient
pyjwt
EOF

cat > helpers/validations.py << EOF
from flask import current_app as app
from flask import jsonify, request
import jwt
from functools import wraps
from models import ma
from marshmallow import ValidationError


def token_required(**parameters):
    def inner_function(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            token: str = request.headers.get('x-access-token', None)

            if not token:
                return jsonify({'message': 'Token is missing!'}), 401

            table = parameters.get('table', app.config['TABLE_VALIDATE_TOKEN'])
            key = parameters.get('key', app.config['SECRET_KEY'])
            print(key)
            try:
                data = jwt.decode(token, key)
                current_user = table.query.filter_by(id=data['id']).first()
            except (jwt.ExpiredSignature, jwt.InvalidSignatureError, jwt.DecodeError):
                return jsonify({'message': 'Token is invalid!'}), 401
            return f(*args, current_user, **kwargs)
        return wrapper
    return inner_function


def validate_json(schema: ma.Schema):
    def inner_function(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            try:
                schema.load(request.json)
            except ValidationError as err:
                return err.messages
            return f(*args, **kwargs)
        return wrapper
    return inner_function
EOF

cat > models/table_example.py << EOF
from . import db, ma, Standard
from werkzeug.security import generate_password_hash, check_password_hash
from marshmallow import validate


class TableExample(db.Model, Standard):
    __tablename__ = 'TableExample'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

    def __init__(self, fields: dict):
        self.changes(fields)

    def changes(self, fields: dict):
        self.name = fields.get('name')
        self.password = self.__generate_password(fields.get('password'))
        self.email = fields.get('email')

    @staticmethod
    def __generate_password(password: str) -> str:
        return generate_password_hash(password)

    def compare_passwords(self, password: str) -> bool:
        return check_password_hash(self.password, password)


class TableExample_Schema(ma.Schema):
    name = ma.Str(validate=validate.Length(min=1), required=True)
    email = ma.Email(required=True)
    password = ma.Str(validate=validate.Length(min=4), load_only=True, required=True)

    class Meta:
        fields = ('id', 'name', 'email', 'password')
EOF

cat > models/Login.py << EOF
from . import ma
from marshmallow import validate


class LoginSchema(ma.Schema):
    email = ma.Email(required=True)
    password = ma.Str(validate=validate.Length(min=8), required=True)
EOF

cat > routes/example_routes.py << EOF
from . import example
from models.table_example import TableExample, TableExample_Schema
from routes.create_routesStandars import create_routes

create_routes(
    table=TableExample,
    table_schema=TableExample_Schema,
    blueprint=example,
    noun="example",
    login_endpoint=True)
EOF
}
poetry_install () {
  poetry init -n
  poetry add -D pytest Black flake8
  cat requirements.txt | xargs -L 1 poetry add
  rm requirements.txt
}
install_dep (){
    tempfile="/tmp/install_d.log"
    echo -ne "\e[97m=>\e[0m \e[31m\uf8d5\e[0m Instalando dependencias\r"
    poetry_install 2>/dev/null 1>>$tempfile &
    while ps |grep $! &>/dev/null; do
        echo -ne "\e[97m=>\e[0m \e[32m\uf8d6\e[0m Instalando dependencias\r"
        sleep 1
        echo -ne "\e[97m=>\e[0m \e[31m\uf8d5\e[0m Instalando dependencias\r"
        sleep 1
    done
    echo -ne "\e[97m=>\e[0m \e[32m\uf8d6\e[0m Dependencias Instaladas\r"
    rm $tempfile

}
make_dockerfile (){
mkdir .devcontainer
cd .devcontainer
cat > devcontainer.json << EOF
{
  "name": "Docker python",
  "dockerFile": "Dockerfile",
  "appPort": 3000,
  //"postCreateCommand": "mysqld &"
  "postCreateCommand": "mysqld_safe --skip-grant-tables &"
}
EOF

cat > Dockerfile << EOF
FROM python:3.8-alpine
RUN apk add --no-cache --purge -uU mysql mysql-client mariadb-dev mariadb-connector-c
RUN apk add --no-cache --virtual build-deps gcc musl-dev
RUN rm -rf /var/cache/apk/* /tmp/*
RUN pip install flask flask_sqlalchemy flask_marshmallow marshmallow-sqlalchemy mysqlclient pyjwt flask-cors
RUN apk del build-deps mariadb-dev
EXPOSE 3306
EOF
echo -e "\n\e[91m=>\e[0m \e[36m\uf308\e[0m Dokerfile Creado"
}
make_project (){
    echo -e "\e[34m=>\e[0m \e[96m\ue5fc\e[0m Folders Creados"
    mkdir routes models helpers config
    echo -e "\e[35m=>\e[0m \e[33m\ue235\e[0m Pyfiles Creados"
    make_pyfiles
}
while getopts n:idp flag
do
    case "${flag}" in
        n) projectname=${OPTARG};;
        i) init=true;;
        d) docker=true;;
        p) poetry=true;;
        *)
            echo 'La vandera no existe' >&2
            exit 1
        ;;
    esac
done
if [ $init ] && [ ! $projectname ];then
    make_project
    if [ $docker ] && [ $poetry ];then
        make_dockerfile
        install_dep
    elif [ $poetry ];then
        install_dep
    elif [ $docker ];then
        make_dockerfile
    fi
    echo -e "\e[96m=>\e[0m \e[92m\uf00c\e[0m Inicializado"
elif [ ! $init ] && [ $projectname ];then
    if [ -d $(pwd)/$projectname ];then
        echo -e "\e[31m\ue009\e[0m\e[5m El proyecto ya exite en su sistema\e[0m"
    else
        echo -e "\e[93m=>\e[0m \e[30m\uf593\e[0m Creando API REST flask $projectname"
        mkdir $projectname
        cd $projectname
        make_project
        if [ $docker ] && [ $poetry ];then
            make_dockerfile
            install_dep
        elif [ $poetry ];then
            install_dep
        elif [ $docker ];then
            make_dockerfile
        fi
        echo -e "\e[96m=>\e[0m \e[92m\uf00c\e[0m $projectname Creado"
    fi
elif [ $docker ] && [ $poetry ] && [ ! $init ] && [ ! $projectname ];then
    make_dockerfile
    install_dep
elif [ $docker ] && [ ! $init ] && [ ! $projectname ] && [ ! $poetry ];then
    make_dockerfile
elif [ $poetry ] && [ ! $init ] && [ ! $projectname ] && [ ! $docker ];then
    install_dep
else
    echo -e "\e[31m\ue009\e[0m\e[5m Eror en la secuencia de vandera -n y -i no deben usarse juntas\e[0m" >&2
    exit 1
fi
