#!/bin/bash
make_pyfiles () {
cat > .gitignore << EOF
# Created by https://www.gitignore.io/v1/example,visualstudiocode,virtualenv
# Edit at https://www.gitignore.io/?templates=python,visualstudiocode,virtualenv

### Python ###
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# Mr Developer
.mr.developer.cfg
.project
.pydevproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

### VirtualEnv ###
# Virtualenv
# http://iamzed.com/2009/05/07/a-primer-on-virtualenv/
pyvenv.cfg
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
pip-selfcheck.json

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

### VisualStudioCode Patch ###
# Ignore all local history of files
.history

# End of https://www.gitignore.io/v1/example,visualstudiocode,virtualenv
#temporal archives
*~
#poetry
poetry.lock
#pyC
*.pyc
#coderuner
tempCodeRunnerFile.py
EOF

cat > server.py << EOF
from flask import Flask, jsonify
from config import DevelopmentConfig
from routes.example_routes import example
app = Flask(__name__)
app.config.from_object(DevelopmentConfig)


# * Error 404
@app.errorhandler(404)
def page_not_found(err):
    return jsonify({"Message": "This page could not be found"})


# * Error 405
@app.errorhandler(405)
def method_not_allowed(err):
    return jsonify({"Message": "The method is not allowed for the requested URL"})


# * index route

# * Routes
app.register_blueprint(example)
EOF

cat > run.py << EOF
from server import app
from models import ma
from models.database_init import db, create_database


if __name__ == "__main__":
    db.init_app(app)
    ma.init_app(app)
    with app.app_context():
        create_database()
        db.create_all()
    app.run()
EOF

cat > config/__init__.py << EOF
from os import environ


class Config:
    SECRET_KEY = "CRAG"


class DevelopmentConfig(Config):
    DEBUG = True
    EGINE_URI = 'mysql://root:' + environ['passmaria'] + '@localhost'
    # * EGINE_URI = 'mysql://root:@localhost'
    DB_NAME = 'exampledb'
    SQLALCHEMY_DATABASE_URI = f'{EGINE_URI}/{DB_NAME}'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
EOF

cat > models/__init__.py << EOF
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from sqlalchemy import exc
db = SQLAlchemy()
ma = Marshmallow()


class Standard:
    def save(self):
        db.session.add(self)
        try:
            db.session.commit()
        except exc.SQLAlchemyError:
            db.session.rollback()
            return False
        return True

    def delete(self):
        db.session.delete(self)
        try:
            db.session.commit()
        except exc.SQLAlchemyError:
            return False
        return True
EOF

cat > models/database_init.py << EOF
from flask import current_app as app
from . import db
from .table_example import TableExample


def create_database():
    engine = db.create_engine(app.config['EGINE_URI'], {})
    engine.execute(f"CREATE DATABASE IF NOT EXISTS {app.config['DB_NAME']}")


class TableExample(TableExample):
    def __init__(self):
        super(TableExample, self).__init__()
EOF

cat > routes/__init__.py << EOF
from flask import Blueprint
example = Blueprint('example', __name__)
EOF

cat > routes/api_template.py << EOF
from flask import jsonify, request
from flask.views import MethodView
import jwt
from flask import current_app as app
import datetime
from helpers.validations import token_required, validate_json


class MethodsApi(MethodView):
    def __init__(self, table, table_schema):
        self.Table = table
        self.Result = table_schema()
        self.Results = table_schema(many=True)
        self.put = validate_json(self.Result)(self.put)
        self.add = validate_json(self.Result)(self.add)
        self.nonexistent_id = jsonify({"Message": "record nonexistent"}), 404

    @token_required
    def get(self, id=None):
        nonexistent_items = jsonify(
            {"Message": "No There are no items for this query"}), 404
        if id:
            one_registry = self.Table.query.filter_by(id=id).first()
            if one_registry:
                return self.Result.jsonify(one_registry)
            return self.nonexistent_id
        else:
            p_busqueda = request.args.to_dict()
            if 'page' in p_busqueda.keys():
                page = int(p_busqueda['page'])
                per_page = int(p_busqueda['size']) if 'size' in p_busqueda.keys() else 10
                paginar = self.Table.query.paginate(page, per_page, False)
                if not paginar.items:
                    return nonexistent_items
                return jsonify(
                    {"Result": self.Results.dump(paginar.items),
                     "total-pages": paginar.pages})
            else:
                all_registrys = self.Table.query.all()
                if not all_registrys:
                    return nonexistent_items
                return self.Results.jsonify(all_registrys)

    def post(self):
        rute = str(request.url_rule)
        if rute.find('login') != -1:
            auth = request.json
            reserr = jsonify({'Authenticate' : 'Could not verify'})
            if not auth or not auth['name'] or not auth['password']:
                return reserr, 401

            table = self.Table.query.filter_by(name=auth['name']).first()

            if not table:
                return reserr, 401

            if table.compare_passwords(auth['password']):
                token = jwt.encode({
                    'id': table.id,
                    'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30),
                }, app.config['SECRET_KEY'])
                return jsonify({'token' : token.decode('UTF-8')})
            return reserr, 401
        else:
            return self.add()

    @token_required
    def add(self):
        new_registry = self.Table(request.json)
        insert_correct_data = new_registry.save()
        if not insert_correct_data:
            return self.databse_err()
        return self.Result.jsonify(new_registry), 201

    @token_required
    def put(self, id=None):
        registry_update = self.Table.query.get(id)
        if not registry_update:
            return self.nonexistent_id
        registry_update.changes(request.json)
        update_correct_data = registry_update.save()
        if not update_correct_data:
            return self.databse_err("update")
        return self.Result.jsonify(registry_update)

    @token_required
    def delete(self, id):
        registry_delete = self.Table.query.get(id)
        if not registry_delete:
            return self.nonexistent_id
        deleted_data = registry_delete.delete()
        if not deleted_data:
            return self.databse_err("delete")
        return self.Result.jsonify(registry_delete)

    @staticmethod
    def databse_err(action: str = "insert") -> jsonify:
        return jsonify(
            {
                "Err": f"Error trying to {action} data",
                "Possibilities": {
                    "1": "Data integrity error",
                    "2": "Could not connect to DB",
                    "3": "The action could not be performed due to an error in the request",
                    "4": "Some other error "
                }
            }), 409
EOF

cat > routes/create_routesStandars.py <<EOF
from routes.api_template import MethodsApi


def create_routes(table: object, table_scheme: object, blueprint_name: object, noun: str, login: bool = False):
    view_func = MethodsApi.as_view(
        f"{noun}_api",
        table,
        table_scheme)
    endpoints = get_endpoints(noun, login)
    for i in endpoints:
        blueprint_name.add_url_rule(
            i[0],
            methods=i[1],
            view_func=view_func)


def get_endpoints(noun: str, login: bool):
    endpont_list = [
        [f'/api/{noun}/', ['POST', 'GET']],
        [f'/api/{noun}/<int:id>', ['GET', 'PUT', 'DELETE']]]
    if login:
        endpont_list.insert(0, [f'/api/{noun}/login', ['POST']])
    return endpont_list
EOF

cat > requirements.txt << EOF
flask
flask_wtf
flask_sqlalchemy
mysqlclient
flask_marshmallow
marshmallow-sqlalchemy
pyjwt
EOF

cat > helpers/validations.py << EOF
from flask import current_app as app
from flask import jsonify, request
import jwt
from functools import wraps
from models.table_example import TableExample
from marshmallow import ValidationError


def token_required(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        token = None
        if 'x-access-token' in request.headers:
            token = request.headers['x-access-token']

        if not token:
            return jsonify({'message': 'Token is missing!'}), 401

        try:
            data = jwt.decode(token, app.config['SECRET_KEY'])
            TableExample.query.filter_by(id=data['id']).first()
        except jwt.ExpiredSignature:
            return jsonify({'message': 'Token is invalid!'}), 401
        return fn(*args, **kwargs)
    return wrapper


def validate_json(schema):
    def inner_function(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            try:
                schema.load(request.json)
            except ValidationError as err:
                return err.messages
            return f(*args, **kwargs)
        return wrapper
    return inner_function
EOF

cat > models/table_example.py << EOF
from . import db, ma, Standard
from werkzeug.security import generate_password_hash, check_password_hash
from marshmallow import validate


class TableExample(db.Model, Standard):
    __tablename__ = 'TableExample'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

    def __init__(self, fields: dict):
        self.changes(fields)

    def changes(self, fields: dict):
        self.name = fields['name']
        self.password = self.__generate_password(fields['password'])
        self.email = fields['email']

    @staticmethod
    def __generate_password(password: str) -> str:
        return generate_password_hash(password)

    def compare_passwords(self, password: str) -> bool:
        return check_password_hash(self.password, password)


class TableExample_Schema(ma.Schema):
    name = ma.Str(validate=validate.Length(min=1))
    email = ma.Email()
    password = ma.Str(validate=validate.Length(min=4), load_only=True)

    class Meta:
        fields = ('id', 'name', 'email', 'password')
EOF

cat > routes/example_routes.py << EOF
from . import example
from models.table_example import TableExample, TableExample_Schema
from routes.create_routesStandars import create_routes

create_routes(TableExample, TableExample_Schema, example, "example")
EOF
}
poetry_install () {
  poetry init -n
  poetry add -D pytest Black flake8
  cat requirements.txt | xargs -L 1 poetry add
  rm requirements.txt
}
install_dep (){
    tempfile="/tmp/install_d.log"
    echo -ne "\e[97m=>\e[0m \e[31m\uf8d5\e[0m Instalando dependencias\r"
    poetry_install 2>/dev/null 1>>$tempfile &
    while ps |grep $! &>/dev/null; do
        echo -ne "\e[97m=>\e[0m \e[32m\uf8d6\e[0m Instalando dependencias\r"
        sleep 1
        echo -ne "\e[97m=>\e[0m \e[31m\uf8d5\e[0m Instalando dependencias\r"
        sleep 1
    done
    echo -ne "\e[97m=>\e[0m \e[32m\uf8d6\e[0m Dependencias Instaladas\r"
    rm $tempfile

}
make_dockerfile (){
mkdir .devcontainer
cd .devcontainer
cat > devcontainer.json << EOF
{
  "name": "Docker python",
  "dockerFile": "Dockerfile",
  "appPort": 3000,
  //"postCreateCommand": "mysqld &"
  "postCreateCommand": "mysqld_safe --skip-grant-tables &"
}
EOF

cat > Dockerfile << EOF
FROM python:3.7-alpine
RUN apk update
RUN apk add mysql mysql-client mariadb-connector-c mariadb-dev
RUN apk add --virtual build-deps gcc musl-dev
RUN pip install flask flask_wtf flask_sqlalchemy flask_marshmallow marshmallow-sqlalchemy mysqlclient pyjwt
EXPOSE 3306
EOF
echo -e "\n\e[91m=>\e[0m \e[36m\uf308\e[0m Dokerfile Creado"
}
make_project (){
    echo -e "\e[34m=>\e[0m \e[96m\ue5fc\e[0m Folders Creados"
    mkdir routes models helpers config
    echo -e "\e[35m=>\e[0m \e[33m\ue235\e[0m Pyfiles Creados"
    make_pyfiles
}
while getopts n:idp flag
do
    case "${flag}" in
        n) projectname=${OPTARG};;
        i) init=true;;
        d) docker=true;;
        p) poetry=true;;
        *)
            echo 'La vandera no existe' >&2
            exit 1
        ;;
    esac
done
if [ $init ] && [ ! $projectname ];then
    make_project
    if [ $docker ] && [ $poetry ];then
        make_dockerfile
        install_dep
    elif [ $poetry ];then
        install_dep
    elif [ $docker ];then
        make_dockerfile
    fi
    echo -e "\e[96m=>\e[0m \e[92m\uf00c\e[0m Inicializado"
elif [ ! $init ] && [ $projectname ];then
    if [ -d $(pwd)/$projectname ];then
        echo -e "\e[31m\ue009\e[0m\e[5m El proyecto ya exite en su sistema\e[0m"
    else
        echo -e "\e[93m=>\e[0m \e[30m\uf593\e[0m Creando API REST flask $projectname"
        mkdir $projectname
        cd $projectname
        make_project
        if [ $docker ] && [ $poetry ];then
            make_dockerfile
            install_dep
        elif [ $poetry ];then
            install_dep
        elif [ $docker ];then
            make_dockerfile
        fi
        echo -e "\e[96m=>\e[0m \e[92m\uf00c\e[0m $projectname Creado"
    fi
elif [ $docker ] && [ $poetry ] && [ ! $init ] && [ ! $projectname ];then
    make_dockerfile
    install_dep
elif [ $docker ] && [ ! $init ] && [ ! $projectname ] && [ ! $poetry ];then
    make_dockerfile
elif [ $poetry ] && [ ! $init ] && [ ! $projectname ] && [ ! $docker ];then
    install_dep
else
    echo -e "\e[31m\ue009\e[0m\e[5m Eror en la secuencia de vandera -n y -i no deben usarse juntas\e[0m" >&2
    exit 1
fi
